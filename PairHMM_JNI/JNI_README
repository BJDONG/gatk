Implementation overview:
Created a new Java class called JNILoglessPairHMM which extends LoglessPairHMM and 
overrides functions from both LoglessPairHMM and PairHMM.
1. Constructor: Call base class constructors. Then, load the JNI library located in this 
directory and call a global init function in the library to determine fields ids for the 
members of classes JNIReadDataHolder and JNIHaplotypeDataHolders
2. initialize(): Override and do nothing as all matrix manipulation is done in the native 
library.
3. computeLikelihoods(): Copies array references for readBases/quals etc and 
haplotypeBases to arrays of JNIReadDataHolder and JNIHaplotypeDataHolders classes. Invokes 
the JNI function to perform the computation and updates the likelihoodMap.

Note: Lots of debug code still left in the files, however, debug code is not executed 
(hopefully, not even compiled into bytecode) because the debug flags are set to false.

On the C++ side, the primary function called is 
Java_org_broadinstitute_sting_utils_pairhmm_JNILoglessPairHMM_jniComputeLikelihoods. It 
uses standard JNI calls to get and return data from/to the Java class JNILoglessPairHMM. 
The last argument to the function is the maximum number of OpenMP threads to use while
computing PairHMM in C++. This option is set when the native function call is made from 
JNILoglessPairHMM computeLikelihoods - currently it is set to 12 (no logical reason). 

Compiling:
Make sure you have icc (Intel C compiler) available. Currently, gcc does not seem to 
support all AVX intrinsics.
Type 'make'. This should create a library called libJNILoglessPairHMM.so .Comment out
OMPCFLAGS if OpenMP is not desired.

Running:
If libJNILoglessPairHMM.so is compiled using icc, make sure that the Intel Composer XE 
libraries are in your LD_LIBRARY_PATH :
source <COMPOSER_XE_DIR>/bin/compilervars.sh intel64
See run.sh in this directory on how to invoke HaplotypeCaller with the native library
