package org.broadinstitute.sting.gatk.walkers.replication_validation;

import com.google.java.contract.Ensures;
import com.google.java.contract.Requires;
import org.broadinstitute.sting.utils.MathUtils;

/**
 * Created by IntelliJ IDEA.
 * User: carneiro
 * Date: 7/21/11
 * Time: 7:14 PM
 * To change this template use File | Settings | File Templates.
 */
public class AlleleCountModel extends ProbabilityModel {
    private int maxAlleleCount;

    private final double THETA = 0.001; // Human heterozygozity rate

    public AlleleCountModel(AlleleCountModelParameters p) {
        maxAlleleCount = p.maxAlleleCount;
        model = calculateLog10ProbabilityDistribution(p.errorModel, p.matches, p.mismatches);
    }

    public AlleleCountModel(AlleleCountModel acm) {
        maxAlleleCount = acm.getMaxAlleleCount();
        model = new double [maxAlleleCount+1];
        for (int ac=0; ac<=maxAlleleCount; ac++) {
            model[ac] = acm.getLog10ProbabilityGivenAC(ac);
        }
    }

    public int getMaxAlleleCount() {
        return maxAlleleCount;
    }


    public void merge(AlleleCountModel mergeModel) {
        // I need to know which model is the largest so I can iterate on him (the j index) and guarantee that
        // once we run out of terms it is because the smaller one (the k index) has exhausted all it's terms
        AlleleCountModel largerModel = (maxAlleleCount >= mergeModel.getMaxAlleleCount()) ? this : mergeModel;
        AlleleCountModel smallerModel = (maxAlleleCount < mergeModel.getMaxAlleleCount()) ? this : mergeModel;

        double [] result = new double [largerModel.getMaxAlleleCount() + smallerModel.getMaxAlleleCount() + 1];
        for (int i=0; i<result.length; i++) {
            double [] sumTerms = new double[i+1];
            int index = 0;
            for (int j= Math.min(i, largerModel.getMaxAlleleCount()); j>=0; j--) {
                int k = Math.min(i - j, smallerModel.getMaxAlleleCount());
                // For models of different size, some combinations are impossible. Once we reach one, no reason in trying any further
                // it means that smaller model is not big enough to keep generating sumTerms.
                if (j + k < i)
                    break;

                sumTerms[index] = largerModel.getLog10ProbabilityGivenAC(j) + smallerModel.getLog10ProbabilityGivenAC(k);
                index++;
            }
        result[i] = MathUtils.log10sumLog10(sumTerms);
        }
        model = result;
    }

    @Requires({"ac>=0", "ac<=maxAlleleCount"})
    @Ensures({"result <= 0", "! Double.isInfinite(result)", "! Double.isNaN(result)"})
    public double getLog10ProbabilityGivenAC(int ac) {
        return model[ac];
    }

    @Requires({"ac>=0", "ac<=maxAlleleCount", "log10p <= 0", "! Double.isInfinite(log10p)", "! Double.isNaN(log10p)"})
    public void setLog10ProbabilityGivenAC(int ac, double log10p) {
        model[ac] = log10p;
    }


    /**
     * The prior probability of an allele count being observed based solely on the human heterozygozity rate
     * and the number of samples
     *
     * @param ac given allele count
     * @return the prior probability of ac
     */
    public double log10PriorAC (int ac) {
        // prior probability for a given allele count is THETA/AC.
        if (ac > 0)
            return Math.log10(THETA/ac);

        // if allele count is 0, the prior is one minus the sum of all other possibilities.
        double result = 0.0;
        for (int i=1; i<=maxAlleleCount; i++)
            result += THETA/i;
        return Math.log10(1-result);
    }

    /**
     * Calculates the pool's probability for all possible allele counts. Calculation is based on the error model
     * generated by the reference sample on the same lane. The probability is given by :
     *
     * Pr(ac=j | pool, errorModel) = sum_over_all_Qs ( Pr(ac=j) * Pr(errorModel_q) * [ (n-j/2n) * (1-e) + (j/n)*e]^m * [(n-j/n)*e + (j/n) * (1-e)]^(1-m)
     *
     * where:
     *  n = number of chromosomes
     *  e = probability of an error at a given Q level (e.g. Q30 = 0.001, Q20 = 0.01, ...)
     *  m = number of mismatches
     *
     * @param errorModel
     * @param matches
     * @param mismatches
     * @return
     */
    public double [] calculateLog10ProbabilityDistribution (ErrorModel errorModel, int matches, int mismatches) {
        double [] p = new double[maxAlleleCount+1];
        for (int ac=0; ac<=maxAlleleCount; ac++) {
            p[ac] = calculateLog10ProbabilityGivenAC(ac, errorModel, matches, mismatches);
        }
        return p;
    }

    @Requires({"ac >= 0", "ac <= maxAlleleCount", "errorModel != null", "matches >= 0", "mismatches >= 0" })
    @Ensures({"result <= 0", "! Double.isInfinite(result)", "! Double.isNaN(result)"})
    private double calculateLog10ProbabilityGivenAC(int ac, ErrorModel errorModel, int matches, int mismatches) {
        double log10PAC = log10PriorAC(ac);

        // for each quality probability in the model, calculate the probability of the allele count = ac
        // we skip Q0 because it's meaningless.
        double [] acc = new double[errorModel.size()]; // we're skipping Q0 so we don't need maxQualityScore + 1 here.
        for (byte qual = errorModel.getMinQualityScore(); qual <= errorModel.getMaxQualityScore(); qual++) {
            final int i = qual - errorModel.getMinQualityScore();
            acc[i] = calculateLog10ProbabilityOfACGivenQual(qual, ac, errorModel, matches, mismatches);
        }
        return log10PAC + MathUtils.log10sumLog10(acc);
    }

    @Requires({"ac >= 0", "ac <= maxAlleleCount", "errorModel != null", "qual >= errorModel.getMinQualityScore()", "qual <= errorModel.getMaxQualityScore()", "matches >= 0", "mismatches >= 0" })
    @Ensures({"result <= 0", "! Double.isInfinite(result)", "! Double.isNaN(result)"})
    private double calculateLog10ProbabilityOfACGivenQual(byte qual, int ac, ErrorModel errorModel, int matches, int mismatches) {
        double p = (double) ac / maxAlleleCount;
        double q = 1 - p;
        double e = MathUtils.phredScaleToProbability(qual);
        double x = Math.log10(q * (1-e) + p * e);
        double y = Math.log10(q * e + p * (1-e));
        return errorModel.getErrorGivenQual(qual) + matches * x + mismatches * y;
    }

}
