/**
 * Created with IntelliJ IDEA.
 * User: carneiro
 * Date: 9/25/12
 * Time: 12:04 PM
 */

package org.broadinstitute.sting.queue.qscripts

import org.broadinstitute.sting.queue.extensions.gatk._
import org.broadinstitute.sting.queue.QScript
import org.broadinstitute.sting.queue.extensions.picard._
import org.broadinstitute.sting.gatk.walkers.indels.IndelRealigner.ConsensusDeterminationModel
import org.broadinstitute.sting.utils.baq.BAQ.CalculationMode

import collection.JavaConversions._
import net.sf.samtools.SAMFileReader
import net.sf.samtools.SAMFileHeader.SortOrder

import org.broadinstitute.sting.queue.util.QScriptUtils
import org.broadinstitute.sting.queue.function.ListWriterFunction
import org.broadinstitute.sting.commandline.Hidden

class CMIProcessingPPL extends QScript {
  qscript =>

  /****************************************************************************
    * Required Parameters
    ****************************************************************************/

  @Input(doc="a BAM list of one or more raw BAMs", fullName="bam_list", shortName="bl", required=true)
  var bamList: File = _

  @Input(doc="Reference fasta file", fullName="reference", shortName="R", required=true)
  var reference: File = _

  @Input(doc="DBSNP or known callset to use (must be in VCF format)", fullName="dbsnp", shortName="D", required=true)
  var dbSNP: Seq[File] = Seq()

  /****************************************************************************
    * Optional Input Parameters
    ****************************************************************************/

  @Input(doc="List of indices of tumor BAMs", fullName="tumor", shortName="t", required=false)
  var tumorBAMs: Seq[Int] = _

  @Argument(doc="Perform pair ended analysis", fullName="pair_ended", shortName="pe", required=false)
  var pairEndedAnalysis: Boolean = false


  /****************************************************************************
    * Additional Parameters
    ****************************************************************************/

  @Input(doc="extra VCF files to use as reference indels for Indel Realignment", fullName="extra_indels", shortName="indels", required=false)
  var indels: Seq[File] = Seq()

  @Input(doc="The path to the binary of bwa (usually BAM files have already been mapped - but if you want to remap this is the option)", fullName="path_to_bwa", shortName="bwa", required=false)
  var bwaPath: File = _

  @Argument(doc="Use BWASW instead of BWA aln", fullName="use_bwa_sw", shortName="bwasw", required=false)
  var useBWAsw: Boolean = false

  @Argument(doc="Number of threads BWA should use", fullName="bwa_threads", shortName="bt", required=false)
  var bwaThreads: Int = 1

  @Argument(doc="Perform validation on the BAM files", fullName="validation", shortName="vs", required=false)
  var validation: Boolean = false


  /****************************************************************************
    * Hidden Parameters
    ****************************************************************************/
  @Hidden
  @Argument(doc="How many ways to scatter/gather", fullName="scatter_gather", shortName="sg", required=false)
  var nContigs: Int = 0

  @Hidden
  @Argument(doc="Define the default platform for Count Covariates -- useful for techdev purposes only.", fullName="default_platform", shortName="dp", required=false)
  var defaultPlatform: String = ""

  @Hidden
  @Argument(doc="Run the pipeline in test mode only", fullName = "test_mode", shortName = "test", required=false)
  var testMode: Boolean = false


  /****************************************************************************
    * Global Variables
    ****************************************************************************/
  val bwaParameters: String = " -q 5 -l 32 -k 2 -t 4 -o 1 "
  val cleaningExtension: String = ".clean.bam"

  /****************************************************************************
    * Main script
    ****************************************************************************/

  def script() {

    val bams: Seq[File] = QScriptUtils.createSeqFromFile(bamList)

    assert(bams.length <= 5, "Current implementation is limited to 5 bams. See source code for details on the n-way out indel cleaning procedure")

    val alnBAMs = performAlignment()

    // BAM files generated by the pipeline

    clean(alnBAMs)

    for (bam <- alnBAMs) {
      val cleanBAM  = swapExt(bam, ".bam", ".clean.bam")
      val dedupBAM  = swapExt(bam, ".bam", ".clean.dedup.bam")
      val recalBAM  = swapExt(bam, ".bam", ".clean.dedup.recal.bam")

      // Accessory files
      val metricsFile     = swapExt(bam, ".bam", ".metrics")
      val preRecalFile    = swapExt(bam, ".bam", ".pre_recal.table")
      val postRecalFile   = swapExt(bam, ".bam", ".post_recal.table")

      add(dedup(cleanBAM, dedupBAM, metricsFile),
            bqsr(dedupBAM, preRecalFile),
          recal(dedupBAM, preRecalFile, recalBAM),
            bqsr(recalBAM, postRecalFile))
    }
  }

  /****************************************************************************
    * Helper classes and methods
    ****************************************************************************/

  class ReadGroup (val id: String,
                   val lb: String,
                   val pl: String,
                   val pu: String,
                   val sm: String,
                   val cn: String,
                   val ds: String)
  {}

  // Rebuilds the Read Group string to give BWA
  def addReadGroups(inBam: File, outBam: File, samReader: SAMFileReader) {
    val readGroups = samReader.getFileHeader.getReadGroups
    var index: Int = readGroups.length
    for (rg <- readGroups) {
      val intermediateInBam: File = if (index == readGroups.length) { inBam } else { swapExt(outBam, ".bam", index+1 + "-rg.bam") }
      val intermediateOutBam: File = if (index > 1) {swapExt(outBam, ".bam", index + "-rg.bam") } else { outBam}
      val readGroup = new ReadGroup(rg.getReadGroupId, rg.getLibrary, rg.getPlatform, rg.getPlatformUnit, rg.getSample, rg.getSequencingCenter, rg.getDescription)
      add(addReadGroup(intermediateInBam, intermediateOutBam, readGroup))
      index = index - 1
    }
  }

  /**
   * BWA alignment
   *
   * @return
   */
  def performAlignment(): Seq[File] = {
    var alnBAMs: Seq[File] = Seq()

    for (bam <- bamList) {
      val ext: String = ".bam"
      val saiFile1: File = swapExt(bam, ext, ".1.sai")
      val saiFile2: File = swapExt(bam, ext, ".2.sai")
      val alnSAM: File   = swapExt(bam, ext, ".sam")
      val alnBAM: File   = swapExt(alnSAM, ".sam", ".aln.bam")
      val rgBAM : File   = swapExt(alnBAM, ".bam", ".rg.bam")

      if (pairEndedAnalysis) {
        add(bwa(" -b1 ", bam, saiFile1),
            bwa(" -b2 ", bam, saiFile2),
            bwa_sam_pe(bam, bam, saiFile1, saiFile2, alnSAM))
      }
      else {
        add(bwa(" -b ", bam, saiFile1),
            bwa_sam_se(bam, saiFile1, alnSAM))
      }
      add(sortSam(alnSAM, alnBAM, SortOrder.coordinate))
      addReadGroups(alnBAM, rgBAM, new SAMFileReader(alnSAM))
      alnBAMs :+= rgBAM
    }

    alnBAMs
  }

  def clean(allBAMs: Seq[File]) {
    val bam: File = allBAMs(0)
    val targetIntervals = swapExt(bam, ".bam", ".cleaning_intervals")
    add(target(allBAMs, targetIntervals), indel(allBAMs, targetIntervals))
  }



  /****************************************************************************
    * Classes (GATK Walkers)
    ****************************************************************************/



  // General arguments to non-GATK tools
  trait ExternalCommonArgs extends CommandLineFunction {
    this.memoryLimit = 4
    this.isIntermediate = true
  }

  // General arguments to GATK walkers
  trait CommandLineGATKArgs extends CommandLineGATK with ExternalCommonArgs {
    this.reference_sequence = qscript.reference
  }

  trait SAMargs extends PicardBamFunction with ExternalCommonArgs {
    this.maxRecordsInRam = 100000
  }

  case class target (inBams: Seq[File], outIntervals: File) extends RealignerTargetCreator with CommandLineGATKArgs {
    this.input_file = inBams
    this.out = outIntervals
    this.mismatchFraction = 0.0
    this.known ++= qscript.dbSNP
    if (indels != null)
      this.known ++= qscript.indels
    this.scatterCount = nContigs
    this.analysisName = outIntervals + ".target"
    this.jobName = outIntervals + ".target"
  }

  case class indel (inBams: Seq[File], tIntervals: File) extends IndelRealigner with CommandLineGATKArgs {
    this.input_file = inBams
    this.targetIntervals = tIntervals
    this.nWayOut = cleaningExtension
    this.known ++= qscript.dbSNP
    if (qscript.indels != null)
      this.known ++= qscript.indels
    this.consensusDeterminationModel = ConsensusDeterminationModel.USE_READS
    this.compress = 0
    this.noPGTag = qscript.testMode
    this.scatterCount = nContigs
    this.analysisName = inBams(0).toString + "clean"
    this.jobName = inBams(0).toString + ".clean"

    // Generating the output files for Queue to keep track
    // TODO -- THIS IS A WORKAROUND QUEUE'S LIMITATION ON TRACKING LISTS OF FILES (Limited to 5 files)
    @Output(doc="first cleaned bam file") var out1 = swapExt(inBams(0), ".bam", cleaningExtension)
    @Output(doc="first cleaned bam file") var out2 = if (inBams.length >= 2) {swapExt(inBams(1), ".bam", cleaningExtension)}
    @Output(doc="first cleaned bam file") var out3 = if (inBams.length >= 3) {swapExt(inBams(2), ".bam", cleaningExtension)}
    @Output(doc="first cleaned bam file") var out4 = if (inBams.length >= 4) {swapExt(inBams(3), ".bam", cleaningExtension)}
    @Output(doc="first cleaned bam file") var out5 = if (inBams.length >= 5) {swapExt(inBams(4), ".bam", cleaningExtension)}
  }

  case class bqsr (inBam: File, outRecalFile: File) extends BaseRecalibrator with CommandLineGATKArgs {
    this.knownSites ++= qscript.dbSNP
    this.covariate ++= Seq("ReadGroupCovariate", "QualityScoreCovariate", "CycleCovariate", "ContextCovariate")
    this.input_file :+= inBam
    this.disable_indel_quals = true
    this.out = outRecalFile
    if (!defaultPlatform.isEmpty) this.default_platform = defaultPlatform
    this.scatterCount = nContigs
    this.analysisName = outRecalFile + ".covariates"
    this.jobName = outRecalFile + ".covariates"
  }

  case class recal (inBam: File, inRecalFile: File, outBam: File) extends PrintReads with CommandLineGATKArgs {
    this.input_file :+= inBam
    this.BQSR = inRecalFile
    this.baq = CalculationMode.CALCULATE_AS_NECESSARY
    this.out = outBam
    this.scatterCount = nContigs
    this.isIntermediate = false
    this.analysisName = outBam + ".recalibration"
    this.jobName = outBam + ".recalibration"
  }



  /****************************************************************************
    * Classes (non-GATK programs)
    ****************************************************************************/


  case class dedup (inBam: File, outBam: File, metricsFile: File) extends MarkDuplicates with ExternalCommonArgs {
    this.input :+= inBam
    this.output = outBam
    this.metrics = metricsFile
    this.memoryLimit = 16
    this.analysisName = outBam + ".dedup"
    this.jobName = outBam + ".dedup"
  }

  case class joinBams (inBams: Seq[File], outBam: File) extends MergeSamFiles with ExternalCommonArgs {
    this.input = inBams
    this.output = outBam
    this.analysisName = outBam + ".joinBams"
    this.jobName = outBam + ".joinBams"
  }

  case class sortSam (inSam: File, outBam: File, sortOrderP: SortOrder) extends SortSam with ExternalCommonArgs {
    this.input :+= inSam
    this.output = outBam
    this.sortOrder = sortOrderP
    this.analysisName = outBam + ".sortSam"
    this.jobName = outBam + ".sortSam"
  }

  case class validate (inBam: File, outLog: File) extends ValidateSamFile with ExternalCommonArgs {
    this.input :+= inBam
    this.output = outLog
    this.REFERENCE_SEQUENCE = qscript.reference
    this.isIntermediate = false
    this.analysisName = outLog + ".validate"
    this.jobName = outLog + ".validate"
  }


  case class addReadGroup (inBam: File, outBam: File, readGroup: ReadGroup) extends AddOrReplaceReadGroups with ExternalCommonArgs {
    this.input :+= inBam
    this.output = outBam
    this.RGID = readGroup.id
    this.RGCN = readGroup.cn
    this.RGDS = readGroup.ds
    this.RGLB = readGroup.lb
    this.RGPL = readGroup.pl
    this.RGPU = readGroup.pu
    this.RGSM = readGroup.sm
    this.analysisName = outBam + ".rg"
    this.jobName = outBam + ".rg"
  }

  case class revert (inBam: File, outBam: File, removeAlignmentInfo: Boolean) extends RevertSam with ExternalCommonArgs {
    this.output = outBam
    this.input :+= inBam
    this.removeAlignmentInformation = removeAlignmentInfo
    this.sortOrder = if (removeAlignmentInfo) {SortOrder.queryname} else {SortOrder.coordinate}
    this.analysisName = outBam + "revert"
    this.jobName = outBam + ".revert"
  }

  case class convertToFastQ (inBam: File, outFQ: File) extends SamToFastq with ExternalCommonArgs {
    this.input :+= inBam
    this.fastq = outFQ
    this.analysisName = outFQ + "convert_to_fastq"
    this.jobName = outFQ + ".convert_to_fastq"
  }

  case class bwa_sam_se (inBam: File, inSai: File, outBam: File) extends CommandLineFunction with ExternalCommonArgs {
    @Input(doc="bam file to be aligned") var bam = inBam
    @Input(doc="bwa alignment index file") var sai = inSai
    @Output(doc="output aligned bam file") var alignedBam = outBam
    def commandLine = bwaPath + " samse " + reference + " " + sai + " " + bam + " > " + alignedBam
    this.memoryLimit = 6
    this.analysisName = outBam + ".bwa_sam_se"
    this.jobName = outBam + ".bwa_sam_se"
  }

  case class bwa_sam_pe (inFile1: File, inFile2: File, inSai1: File, inSai2:File, outBam: File) extends CommandLineFunction with ExternalCommonArgs {
    @Input(doc="bam file to be aligned") var first = inFile1
    @Input(doc="bam file to be aligned") var second = inFile2
    @Input(doc="bwa alignment index file for 1st mating pair") var sai1 = inSai1
    @Input(doc="bwa alignment index file for 2nd mating pair") var sai2 = inSai2
    @Output(doc="output aligned bam file") var alignedBam = outBam
    def commandLine = bwaPath + " sampe " + reference + " " + sai1 + " " + sai2 + " " + first + " " + second + " > " + alignedBam
    this.memoryLimit = 6
    this.analysisName = outBam + ".bwa_sam_pe"
    this.jobName = outBam + ".bwa_sam_pe"
  }

  case class bwa_sw (inFastQ: File, outBam: File) extends CommandLineFunction with ExternalCommonArgs {
    @Input(doc="fastq file to be aligned") var fq = inFastQ
    @Output(doc="output bam file") var bam = outBam
    def commandLine = bwaPath + " bwasw -t " + bwaThreads + " " + reference + " " + fq + " > " + bam
    this.analysisName = outBam + ".bwasw"
    this.jobName = outBam + ".bwasw"
  }
  
  
  case class bwa (inputParms: String, inBam: File, outSai: File) extends CommandLineFunction with ExternalCommonArgs {
    @Input(doc="bam file to be aligned") var bam = inBam
    @Output(doc="output sai file") var sai = outSai
    def commandLine = bwaPath + " aln -t " + bwaThreads + bwaParameters + reference + inputParms + bam + " > " + sai
    this.analysisName = outSai + ".bwa_aln_se"
    this.jobName = outSai + ".bwa_aln_se"
  }

  case class writeList(inBams: Seq[File], outBamList: File) extends ListWriterFunction {
    this.inputFiles = inBams
    this.listFile = outBamList
    this.analysisName = outBamList + ".bamList"
    this.jobName = outBamList + ".bamList"
  }
}

